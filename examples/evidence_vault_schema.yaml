# Evidence Vault Schema v1.0
# AI-HPP-2026 Compliant
#
# This schema defines the structure for logging AI decisions
# to enable post-hoc audit and interpretability.
#
# Core Principle: All consequential decisions must be recorded
# with sufficient context to understand WHY the decision was made.

decision_record:
  # Unique identification and versioning
  metadata:
    id: "uuid"                          # Unique decision ID
    timestamp_ms: "int64"               # Unix timestamp (milliseconds)
    agent_id: "string"                  # Which agent made this decision
    agent_version: "string"             # Agent software version
    constitution_hash: "sha256"         # Hash of constitution used
    parent_decision_id: "uuid | null"   # If spawned from another decision

  # Context in which decision was made
  context:
    situation_type: "enum[routine, consequential, critical, life_safety]"
    time_pressure: "enum[none, low, medium, high, immediate]"
    human_in_loop: "boolean"            # Was human consulted?
    human_id: "string | null"           # Which human (if applicable)
    environment_state: "json"           # Relevant environmental data

  # The decision-making process
  decision:
    options_considered:
      - option_id: "string"             # e.g., "option_a", "hack_1"
        description: "string"           # What is this option?
        predicted_outcomes:
          fatality_probability: "float[0,1]"
          injury_severity: "float[0,1]"    # 0=none, 1=severe
          property_damage: "float"          # Estimated cost
          distress_duration_minutes: "float"
          space_violation: "boolean"
        rejection_reason: "string | null"  # Why NOT chosen (if rejected)

    selected_option: "string"           # Which option was chosen
    selection_rationale: "string"       # WHY this option was chosen
    engineering_hack_attempted: "boolean"  # Did we search U_hack?
    hack_search_time_ms: "int"          # How long did we search?

  # Interpretability data (v3.0 addition)
  interpretability:
    tier_used: "enum[quick, standard, deep]"  # Which interpretability tier
    honesty_probe_score: "float | null"       # Honesty metric (if available)
    goal_consistency_score: "float | null"    # Goal alignment metric
    attention_to_safety: "float | null"       # Attention on safety tokens
    deception_probability: "float | null"     # P(deception | activations)
    circuit_analysis_available: "boolean"     # Was deep analysis possible?

  # Actual outcome (filled post-execution)
  outcome:
    actual_result: "string"             # What actually happened
    fatalities: "int"                   # Actual deaths (should be 0)
    injuries: "int"                     # Actual injuries
    injury_severity_avg: "float[0,1]"   # Average severity of injuries
    property_damage: "float"            # Actual cost
    distress_detected: "boolean"        # Was distress observed?
    distress_duration_minutes: "float"  # Actual distress duration

  # Post-hoc audit and learning
  audit:
    retrospective_assessment: "string"  # Looking back, was this correct?
    could_have_been_prevented: "boolean"  # Could we have avoided this?
    lessons_learned: "string[]"         # What should we learn?
    similar_cases: "uuid[]"             # IDs of similar past decisions
    review_status: "enum[pending, reviewed, disputed]"
    reviewer_id: "string | null"        # Human reviewer
    review_timestamp_ms: "int64 | null"

  # Provenance tracking (v3.0 addition)
  provenance:
    data_sources:
      - source_id: "string"             # Where did data come from?
        source_type: "enum[sensor, database, external_api, ai_generated]"
        trust_level: "enum[verified, public, synthetic, unknown]"
        trust_score: "float[0,1]"       # Numeric trust
        signature: "string | null"      # Cryptographic signature

    knowledge_used:
      - concept_id: "string"            # What knowledge was applied?
        origin: "string"                # Where did we learn this?
        trust_score: "float[0,1]"       # How much do we trust it?

  # Compute and sustainability (v3.0 addition)
  compute:
    model_used: "string"                # Which model/version
    compute_time_ms: "int"              # Inference time
    energy_consumed_kwh: "float"        # Energy used
    co2_grams: "float"                  # Carbon footprint
    efficiency_tier: "enum[small, medium, large]"  # Model size category

  # Compliance and jurisdiction (v3.0 addition)
  compliance:
    primary_jurisdiction: "string"      # e.g., "EU", "US-CA"
    applicable_frameworks: "string[]"   # ["EU_AI_Act", "NIST_RMF"]
    compliance_verified: "boolean"      # Did we check compliance?
    conflicts_resolved: "string[]"      # Any regulatory conflicts?

  # Sub-agent tracking (v3.0 addition for agentic systems)
  agentic:
    spawned_sub_agents: "uuid[]"        # Sub-agents created for this decision
    constitution_propagated: "boolean"  # Did sub-agents inherit constitution?
    attestation_verified: "boolean"     # Did sub-agents pass attestation?
    violations_detected: "int"          # How many sub-agent violations?

# Index recommendations for querying
indexes:
  - field: "metadata.timestamp_ms"      # Time-based queries
  - field: "context.situation_type"     # Filter by criticality
  - field: "outcome.fatalities"         # Find failures (should be 0!)
  - field: "metadata.agent_id"          # Per-agent analysis
  - field: "audit.review_status"        # Pending reviews

# Retention policy
retention:
  critical_decisions: "indefinite"      # Life-safety: keep forever
  consequential_decisions: "7_years"    # Significant: regulatory minimum
  routine_decisions: "1_year"           # Low-stakes: shorter retention
  personal_data: "2_years"              # GDPR-style privacy (if separate)

# Encryption and access control
security:
  encryption_at_rest: "required"        # AES-256 or better
  encryption_in_transit: "required"     # TLS 1.3+
  access_control: "role_based"          # Who can read/query?
  audit_access_logs: "required"         # Log all vault access
  immutability: "append_only"           # Cannot modify past records

# Example usage:
# This schema would be implemented in a database (e.g., PostgreSQL with JSONB,
# MongoDB, or a specialized time-series DB). The AI system writes to this vault
# for every decision at or above a certain threshold of consequence.
